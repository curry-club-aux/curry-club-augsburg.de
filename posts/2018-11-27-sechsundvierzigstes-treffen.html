<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>libgccjit und libjit :: Curry Club Augsburg</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="shortcut icon" href="../images/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />
    <link rel="stylesheet" href="https://api.tiles.mapbox.com/mapbox.js/v2.1.6/mapbox.css" />
  </head>
  <body>
    <div class="wrap">
      <div class="main">
        <header>
          <div id="logo">
            <a href="../">
              <img src="../images/logo-dunkler-hintergrund.svg" alt="Curry Club Augsburg" />
            </a>
          </div>
          <blockquote>
            <p>Das wird heiß</p>
            <footer>
              &mdash; <cite class="author">Makarius</cite>
            </footer>
          </blockquote>
          <div class="clear"></div>
        </header>

        <main id="content">
          <article>
  <header>
    <h1>libgccjit und libjit</h1>
    <div class="info">
      Gepostet am 27. Nov 18
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Marc trägt über libgccjit vor, Jakob nerdet auf libjit ab.</p>
<p>Was es mit libgccjit auf sich hat?</p>
<p>Auch Implementiererinnen funktionaler Programmiersprachen stehen am Ende vor dem Problem, Programme in (effizienten) Maschinencode übersetzen zu müssen.</p>
<p>Die GCC kann das schon (und zwar für ziemlich viele Architekturen), warum das Rad also zweimal erfinden und nicht auf den GCC aufsetzen?</p>
<p>Dank der Bibliothek libgccjit von David Malcolm, die seit GCC 5.1 offizieller Bestandteil des GCC-Projektes ist, ist es einfach geworden, den GCC als AOT- oder JIT-Compiler-Backend in eigene Programme einzubinden.</p>
<p>Im Vortrag stellt Marc die Bibliothek vor. Wir werden so etwas über die Erzeugung von Maschinencode lernen und einen Blick auf die GCC-Interna werfen.</p>
<p>Daran anschließen könnte natürlich ein gemeinsames Projekt, einen rudimentären Compiler für eine rudimentäre (funktionale) Programmiersprache zu schreiben.</p>
<p>Was es mit libjit auf sich hat? Das ist auch von GNU, aber wurde von Anfang an für JIT-Kompilierung geschrieben. Ursprünglich als JIT-Backend für dotGNU (die .NET-CLR von GNU) wird es inzwischen als eigenständige Bibliothek weiterentwickelt.</p>
<p>Das Vorurteil gegenüber zu JIT umgebauten Offline-Compilern ist ja, dass sie zu viel Zeit zum Kompilieren verwenden (zum Beispiel mit schweren Optimierungen) – selbst bei Code, der nur ein oder wenige Male ausgeführt wird. Ein hastig zusammengebastelter Brainfuck-JIT-Compiler mit dieser Bibliothek (in weniger als 100 Zeilen) produziert zugegebenermaßen nicht so guten Code wie libgccjit; dem Vorurteil gemäß könnte er, die Kompilierzeit addiert, dennoch schneller sein.</p>
</article>

        </main>
      </div>
    </div>

    <footer class="footer">
      Mit viel <b>&lambda;</b> und mit Hilfe von <a href="http://jaspervdj.be/hakyll">Hakyll</a> erstellt.
      Schau dir den <a href="https://github.com/curry-club-aux/curry-club-augsburg.de">Quellcode</a> an und verbessere ihn!<br />
      Sofern nicht anders angegeben, stehen Design, Bilder, Webseite und Texte unter <a href="https://creativecommons.org/licenses/by/3.0/de/">CC BY 3.0 DE</a> und Codeschnipsel unter <a href="https://opensource.org/licenses/MIT">MIT-Lizenz</a>.<br />
      Q: Warum sind alle Formulierungen auf der Website weiblich? A: Weil wir's können.
    </footer>
  </body>
</html>
