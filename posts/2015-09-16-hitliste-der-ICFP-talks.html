<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Hitliste der Talks von der ICFP :: Curry Club Augsburg</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="shortcut icon" href="../images/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />
    <link rel="stylesheet" href="https://api.tiles.mapbox.com/mapbox.js/v2.1.6/mapbox.css" />
  </head>
  <body>
    <div class="wrap">
      <div class="main">
        <header>
          <div id="logo">
            <a href="../">
              <img src="../images/logo-dunkler-hintergrund.svg" alt="Curry Club Augsburg" />
            </a>
          </div>
          <blockquote>
            <p>Das wird heiß</p>
            <footer>
              &mdash; <cite class="author">Makarius</cite>
            </footer>
          </blockquote>
          <div class="clear"></div>
        </header>

        <main id="content">
          <article>
  <header>
    <h1>Hitliste der Talks von der ICFP</h1>
    <div class="info">
      Gepostet am 16. September 2015
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> hat die offizielle Empfehlungsliste des Curry Clubs für Talks von der diesjährigen <a href="http://www.icfpconference.org/">ICFP</a> erstellt. Wir wünschen angenehme Stunden der funktionalen Weiterbildung!</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=ga83zOo95bs">The State of GHC</a> von Simon Peyton Jones<br />
 Ein Ausblick auf GHC 8.0. Pflichtvideo. (Achtung: Comic Sans in gelb auf blau.)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=ZEUTndOzrvw">The State of GHCJS</a> von Luite Stegeman<br />
 Kurzzusammenfassung: GHCJS ist mit GHC 7.10.2 endlich einfach zu installieren. Es gibt eine neue Version der GHCJS-Standardbibliothek. Es steht einem Praxiseinsatz von GHCJS nichts mehr im Wege!</p></li>
<li><p><a href="https://www.youtube.com/watch?v=hI0ajVy2xEk">Practical Probabilistic Programming with Monads</a> von Adam Scibior<br />
 Eine DSL, mit der man bayesische Inferenz betreiben kann. (sehr interessant)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=AFSLMTgoClI">GADTs Meet Their Match</a> von George Karachalias<br />
 Wenn man in Haskell eine Funktion “a -&gt; b” definiert, dann überprüft GHC, ob man mit der Definition jede mögliche Eingabe abgedeckt hat. Das funktioniert aber noch nicht so gut, wenn a ein GADT ist. Der Vortrag beschreibt einen Algorithmus, der dieses Problem löst.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=PrDSxnO29d0">Look Ma, No Signatures!</a> von Edward Z. Yang<br />
 Wie bringt man GHC bei, rekursiv voneinander abhängige Module zu kompilieren? (sehr unterhaltsam)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=T88TDS7L5DY">The Unreasonable Effectiveness of Lenses for Business Applications</a> von Edward Kmett<br />
 Ein Lens-Vortrag vom geliebten Propheten höchstpersönlich. Außerdem: Sonderpreis für den besten Vortragstitel</p></li>
<li><p><a href="https://www.youtube.com/watch?v=WajfYdqCeAM">Practical Principled FRP</a> von Atze van der Ploeg<br />
 Untertitel: Forget the past, change the future! FRPNow! Ein neuer Ansatz für Functional Reactive Programming.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NVEgyJCTee4">The History of Standard ML: Ideas, Principles, Culture</a> von David MacQueen<br />
 Von Makarius empfohlen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=RRmb2RtU0hU">Stack</a> von Emanual Borsboom<br />
 Über die neue <code>cabal</code>-Alternative. Ich habe sehr gute Erfahrungen mit Stack gemacht. Im Gegensatz zu Cabal hatte ich mit Stack noch nie Probleme damit, dass verschiedene Pakete unterschiedliche Versionen von Dependencies vorausgesetzt haben. Es verwendet dazu eine kuratierte Datenbank von Paketen und Schnappschüssen von miteinander verträglichen Versionen von diesen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=lNSfVpKEnnI">Which simple Types have a unique Inhabitant?</a> von Gabriel Scherer<br />
 Es wird ein Algorithmus skizziert, der diese Frage wird im Setting des einfach typisierten Lambda-Kalküls beantwortet. In komplexeren Typsystemen ist diese Frage unentscheidbar. Ein Algorithmus, der diese Frage in vielen Fällen beantwortet kann aber trotzdem hilfreich für Programmierer sein.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=W6a36RoFeNw">Future of Haskell: Dependent types</a> von Richard Eisenberg<br />
 Es gibt den Plan, GHC abhängige Typen beizubringen. Dieser Vortrag stellt kurz (in ca 5min) vor, was damit möglich sein wird. Danach gibt es eine lange Diskussion.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=guMLPr6eBLo">The Remote Monad Design Pattern</a> von Andy Gill<br />
 Wie man durch Bündeln von Kommandos mit möglichst wenigen Netzwerkzugriffen andere Geräte, wie z.B. Toaster steuert.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=oAz8AEf7WDA">Diagrams: A Functional EDSL for Vector Graphics</a> von Ryan Yates und Brent Yorgey<br />
 Über die supercoole Bibliothek <a href="http://projects.haskell.org/diagrams/"><code>diagrams</code></a>, mit der man Vektorgraphiken mit Haskell zeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=D1rm5SnvmKE">Guilt Free Ivory</a> von Galois<br />
 Design einer Haskell-DSL, die sicheren C-Code für eingebettete Systeme erzeugt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NBBQoX1EWCY">Monadic Effects</a> von Niki Vazou und Daan Leijen<br />
 Beschreibt die Sprache Koka, die nach JavaScript kompiliert und ein Effektsystem besitzt. Es ist dabei möglich, eigene Effekte zu implementieren, indem man einfach eine Monadeninstanz schreibt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=nBaRKI5q-DI">Dependent Types for Real time Constraints</a> von William Blair<br />
 Für Real-Time-Systeme (z.B. der Flugkontrolle in einem Flugzeug) gibt es synchrone Programmiersprachen: Diese besitzen einen globalen Taktgeber. Zu jedem Takt werden Daten von Sensoren ausgelesen, Berechnungen ausgeführt oder Anweisungen an andere Systeme geschickt. Nun möchte man in so einem System vielleicht auch Berechnungen haben, die länger dauern als einen Takt, z.B. 10 Takte. Diese müssen mit anderen Berechnungen synchronisiert werden. Um zu überprüfen, dass alle Prozesse aufeinander abgestimmt sind (z.B. ein Prozess erwartet einen Input von einem anderem Prozess genau zu dem Takt wo der andere Prozess fertig ist), kann man abhängige Typen verwenden.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=3Ltgkjpme-Y">Freer Monads, More Extensible Effects</a> von Oleg Kiselyov (<a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Paper</a>)<br />
 Dieses Thema werden wir noch genauer im Curry Club besprechen. Der Vortrag baut auf den Ideen zur performanten Implementierung von freien Monaden des Papers <a href="http://okmij.org/ftp/Haskell/zseq.pdf">Reflection without remorse</a> von der letztjährigen ICFP (<a href="https://youtube.com/watch?v=_XoI65Rxmss">Video des Vortrags</a>) auf.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=bEJKKquyngk">Dependent Types and Effects in F*</a> von Nik Swamy und Catalin Hritcu<br />
 F* ist ein ML-Dialekt, welcher abhängige Typen, Refinement Types und ein Effektsystem kombiniert. Dank Einbinding eines SMT-Solvers können Beweise automatisiert werden. Falls der SMT-Solver scheitert, kann man per Hand einen Beweisterm angeben. Es kann ML-Code extrahiert werden. (Leider auch ein Beispiel dafür, warum man Text auf Folien auf keinen Fall grau machen sollte!)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=_1_3wi_sLKo">Meta Programming and Auto Tuning in the Search for High Performance GPU Code</a> von Michael Vollmer<br />
 Stellt eine DSL vor, mit der man performanten Code für die GPU schreiben kann, vor. Zur Performanceoptimierung des Codes wird eine automatisierte Suche verwendet. Der Programmierer kann die Suchparameter einstellen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=s0wkCKZU3WI">Injective Type Families for Haskell</a> von Jan Stolarek<br />
 Wenn man Haskell programmiert, ist man manchmal gezwungen, Phantom-Parameter einzuführen, deren einziger Zweck es ist, einen Typ eindeutig festzulegen. In vielen Fällen liegt das daran, dass Typfamilien nicht injektiv sind. Das bedeutet, dass wenn TF eine Typfamilie vom Kind * -&gt; * ist, man nicht vom Typ <code>TF a</code> auf den Typ <code>a</code> schließen kann. Deswegen kann man nicht einfach die Typsignatur <code>TF a -&gt; Int</code> verwenden, sondern muss noch einen Phantomtyp einführen: <code>phantom a -&gt; TF a -&gt; Int</code>. (Ich hab leider kein Beispiel aus dem echten Leben zur Hand.) Dieser Vortrag beschreibt, wie man in Zukunft bestimmte Typfamilien in GHC als injektiv kennzeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=UizO7fZSkPY">A Typechecker Plugin for Units of Measure</a> von Adam Gundry<br />
 Wie man ein GHC-Typsystem-Plugin schreibt, das Haskell beibringt, mit physikalischen Einheiten umzugehen. So etwas ist auch in <a href="http://www.idris-lang.org/">Idris</a> ohne weiteres möglich und darum gibt es eine <a href="https://github.com/timjb/quantities">Idris Bibliothek von Tim</a>, die genau das tut.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=UoPoBQRGuZM">Improving Haskell Types with SMT</a> von Iavor S. Diatchki<br />
 Vektoren sind Listen, die mit ihrer Länge indiziert sind. Zum Beispiel ist <code>v :: Vect (S (S Z)) Int</code> eine Liste der Länge zwei bestehend aus <code>Int</code>s. Beim Programmieren mit Vektoren ergeben sich häufig Situation wie die folgende: Man hat Vektoren <code>v :: Vect n a</code>, <code>w :: Vect m a</code> und einen Wert <code>x :: a</code>. Man möchte die Vektoren <code>v</code> und <code>w</code> zusammenhängen mit <code>x</code> als Seperator dazwischen, also <code>v ++ (x : w) :: Vect (S (n + m)) a</code>. Aber dieses Type Judgement ist für GHC nicht nachvollziehbar! Denn <code>v ++ (x : w)</code> hat zunächst den Typ <code>Vect (n + S m) a</code>. Dass <code>n + S m ~ S (n + m)</code> gilt, weiß GHC nicht. Aber man kann es ihm beibringen, indem man ein Typsystemplugin schreibt, welches solche Gleichheiten mit Hilfe eines SMT-Solvers löst.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=K6Uf61U0fvo">Two can keep a Secret if one of them uses Haskell</a> von Alejandro Russo<br />
 Wie man mithilfe des Typsystems das Leaken von sensiblen Daten verhindern kann. Der Programmierer schreibt seinen Code in einer Monade, welche nur Daten von bestimmter Vertraulichkeit lesen oder schreiben kann. Daten sind mit der Vertraulichkeitsebene getaggt. Mit SafeHaskell wird ein Ausbrechen aus diesem Regime verhindert.</p></li>
</ul>
<p>Viel Spaß beim Ansehen!</p>
</article>

        </main>
      </div>
    </div>

    <footer class="footer">
      Mit viel <b>&lambda;</b> und mit Hilfe von <a href="http://jaspervdj.be/hakyll">Hakyll</a> erstellt.
      Schau dir den <a href="https://github.com/curry-club-aux/curry-club-augsburg.de">Quellcode</a> an und verbessere ihn!
    </footer>
  </body>
</html>
