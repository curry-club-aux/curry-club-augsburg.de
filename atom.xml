<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Curry Club Augsburg</title>
    <link href="http://curry-club-augsburg.de/atom.xml" rel="self" />
    <link href="http://curry-club-augsburg.de" />
    <id>http://curry-club-augsburg.de/atom.xml</id>
    <author>
        <name>Curry Club Augsburg</name>
        <email>post@curry-club-augsburg.de</email>
    </author>
    <updated>2019-03-13T00:00:00Z</updated>
    <entry>
    <title>Dialogische Logik</title>
    <link href="http://curry-club-augsburg.de/posts/2019-03-13-treffen-48.html" />
    <id>http://curry-club-augsburg.de/posts/2019-03-13-treffen-48.html</id>
    <published>2019-03-13T00:00:00Z</published>
    <updated>2019-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Dialogische Logik</h1>
    <div class="info">
      Gepostet am 13. Mär 19
      
          von MatthiasHu
      
    </div>
    
    
  </header>

  <p>Dominik wird über dialogische Logik und Dialogspiele vortragen. Dabei handelt es sich um eine Präzisierung der Idee, dass man eine mathematische Aussage nur dann akzeptieren sollte, wenn man jeden noch so kritische Gesprächspartnerin in einem fairen Streitgespräch von ihr überzeugen könnte.</p>
<p>Dialogische Logik ist ein weiterer formaler Ansatz um die Bedeutung logischer Formeln zu charakterisieren. Sie hebt sich von anderen Methoden, wie zum Beispiel Modell-Semantiken und Ableitungssystemen, ab, da sie die interpersonellen Facetten mathematischer Wahrheit explizit macht und somit insbesondere für Intuitionistinnen attraktiv ist. Darüber hinaus hat sie sich auch als ein nützliches technisches Werkzeug entpuppt.</p>
<p>Wir werden sehen, wie Dialoge für Prädikatenlogik erster Stufe aussesehen, warum Dialoge die Lieblingssemantik einer Konstruktivistin sein sollten und was Dominik bis dahin sonst noch Spannendes einfällt.</p>
<p>Wahrscheinlich wird Dominik auch über seine Formalisierung von intuitionistischen Dialogen in Coq berichten.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Spaß mit Agda</title>
    <link href="http://curry-club-augsburg.de/posts/2019-02-19-treffen-47.html" />
    <id>http://curry-club-augsburg.de/posts/2019-02-19-treffen-47.html</id>
    <published>2019-02-19T00:00:00Z</published>
    <updated>2019-02-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Spaß mit Agda</h1>
    <div class="info">
      Gepostet am 19. Feb 19
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Matthias und Ingo veranstalten eine Agda-Sitzung, sicherlich gespickt mit zahlreichen hintergründigen Kommentaren und Ergänzungen von Makarius.</p>
<p>Was ist Agda? Agda ist eine abhängig typisierte funktionale Programmiersprache und ein Beweisassistent.</p>
<p>Was ist die Verbindung zu Isabelle? Isabelle ist viel, viel größer. Beweisautomatisierung ist in Agda extrem unterentwickelt. Isabelle kann noch viel, viel mehr als nur Beweise zu prüfen. In Isabelle schreibt man standardmäßig Beweistexte, während man in Agda direkt Beweisterme angibt. (Dieser Unterschied wird in der Agda-Sitzung erklärt werden.) Der theoretische Unterbau von Agda ist ein ganz anderer als der von Isabelle/HOL (ein Typensystem mit abhängigen Typen statt HOL). Die Community von Agda nerdet meist konstruktiv ab, während die Community von Isabelle sich meist klassische Logik gönnt. Mit Agda kann man auch Homotopietypentheorie (HoTT) betreiben, mit Isabelle/HOL nicht (wohl aber mit reinem Isabelle). Mit Agda kann man in die wundersame Welt prädikativer Mathematik eintauchen. In Agda gibt es den Begriff “universe polymorphism”, den Ingo persönlich sehr verlockend findet.</p>
<p>Von wem ist Agda? Agda wurde von Catarina Coquand auf den Weg gebracht, der Ehefrau von Thierry Coquand, der wiederum die theoretische Basis zur weiteren Theorembeweiseralternative Coq entwickelte. Wir kennen kein weiteres Ehepaar, das von sich behaupten kann, zwei große Theorembeweiserschulen gegründet zu haben.</p>
<p>Wer kann sich besonders auf die Agda-Sitzung freuen? Jede, die verstehen möchte, inwieweit Beweisen und Programmieren ein und dasselbe sind. Jede, die mehr Erfahrung mit abhängigen Typen sammeln möchte. Jede, die (wie etwa Richi vor einiger Zeit) mal aufschnappte, dass manche Ansammlungen in der Mathematik zu groß sind, um “Mengen” zu bilden und stattdessen nur “echte Klassen” sind, und gerne wüssen würde, was es damit auf sich hat. Jede, die sich über einen einfachen Einstieg in die Welt computergeprüfter Beweise freut.</p>
<p>Welche Voraussetzungen setzt die Agda-Sitzung voraus? Keine außer etwas Vertrautheit mit Programmieren.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>libgccjit und libjit</title>
    <link href="http://curry-club-augsburg.de/posts/2018-11-27-sechsundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-11-27-sechsundvierzigstes-treffen.html</id>
    <published>2018-11-27T00:00:00Z</published>
    <updated>2018-11-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>libgccjit und libjit</h1>
    <div class="info">
      Gepostet am 27. Nov 18
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Marc trägt über libgccjit vor, Jakob nerdet auf libjit ab.</p>
<p>Was es mit libgccjit auf sich hat?</p>
<p>Auch Implementiererinnen funktionaler Programmiersprachen stehen am Ende vor dem Problem, Programme in (effizienten) Maschinencode übersetzen zu müssen.</p>
<p>Die GCC kann das schon (und zwar für ziemlich viele Architekturen), warum das Rad also zweimal erfinden und nicht auf den GCC aufsetzen?</p>
<p>Dank der Bibliothek libgccjit von David Malcolm, die seit GCC 5.1 offizieller Bestandteil des GCC-Projektes ist, ist es einfach geworden, den GCC als AOT- oder JIT-Compiler-Backend in eigene Programme einzubinden.</p>
<p>Im Vortrag stellt Marc die Bibliothek vor. Wir werden so etwas über die Erzeugung von Maschinencode lernen und einen Blick auf die GCC-Interna werfen.</p>
<p>Daran anschließen könnte natürlich ein gemeinsames Projekt, einen rudimentären Compiler für eine rudimentäre (funktionale) Programmiersprache zu schreiben.</p>
<p>Was es mit libjit auf sich hat? Das ist auch von GNU, aber wurde von Anfang an für JIT-Kompilierung geschrieben. Ursprünglich als JIT-Backend für dotGNU (die .NET-CLR von GNU) wird es inzwischen als eigenständige Bibliothek weiterentwickelt.</p>
<p>Das Vorurteil gegenüber zu JIT umgebauten Offline-Compilern ist ja, dass sie zu viel Zeit zum Kompilieren verwenden (zum Beispiel mit schweren Optimierungen) – selbst bei Code, der nur ein oder wenige Male ausgeführt wird. Ein hastig zusammengebastelter Brainfuck-JIT-Compiler mit dieser Bibliothek (in weniger als 100 Zeilen) produziert zugegebenermaßen nicht so guten Code wie libgccjit; dem Vorurteil gemäß könnte er, die Kompilierzeit addiert, dennoch schneller sein.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>FizzBuzz, Python und Isabelle</title>
    <link href="http://curry-club-augsburg.de/posts/2018-11-26-fuenfundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-11-26-fuenfundvierzigstes-treffen.html</id>
    <published>2018-11-26T00:00:00Z</published>
    <updated>2018-11-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>FizzBuzz, Python und Isabelle</h1>
    <div class="info">
      Gepostet am 26. Nov 18
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Das 45. Treffen begann nicht wie üblich um 19:00 Uhr, sondern etwas später um 20:25 Uhr. Als inoffizielles Warmup hielt ein <a href="https://www.math.uni-augsburg.de/termin/faszination-2018-11/">Vortrag in der Reihe Faszination Mathematik/Physik</a> her.</p>
<p>Cornelius implementierte FizzBuzz in Python. “Ich möchte nicht spoilern, aber ich kann bereits verraten, dass das Ergebnis in Isabelle/HOL nicht einmal typcheckt.”</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/QswRKkqSoyI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
<p>Anschließend plauderte Makarius über das neue Isabelle/Haskell/PIDE mit Anwendung auf “Automatic Checking of Ordinary Mathematical Texts” (Prof. Peter Koepke, Uni. Bonn). “Das ist zwar erst halb fertig, aber zeigen kann man schon was – vor allem auch das ‘Tooling’ für Haskell: ‘Stack’ und VSCode mit Haskell Language Server. Das füllt locker viele GB RAM + HD, aber dafür muss man selber nichts herumbasteln.”</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/U0KTMdqwmNU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</article>
]]></summary>
</entry>
<entry>
    <title>Lazy Evaluation</title>
    <link href="http://curry-club-augsburg.de/posts/2018-10-30-vierundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-10-30-vierundvierzigstes-treffen.html</id>
    <published>2018-10-30T00:00:00Z</published>
    <updated>2018-10-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Lazy Evaluation</h1>
    <div class="info">
      Gepostet am 30. Okt 18
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Marc hält einen Vortrag über die korrekte Implementierung von Lazy Evaluation (wie in GHC/Haskell) in Umgebungen, die nativ nur Strict Evaluation unterstützen (wie alle Mainstreamsprachen). Wer schon weiß, dass das grundsätzlich mit Thunks/Closures geht, wird eine kleine Überraschung erleben.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Linux-Kernel-Code-Lesung</title>
    <link href="http://curry-club-augsburg.de/posts/2018-08-09-dreiundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-08-09-dreiundvierzigstes-treffen.html</id>
    <published>2018-08-09T00:00:00Z</published>
    <updated>2018-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Linux-Kernel-Code-Lesung</h1>
    <div class="info">
      Gepostet am  9. Aug 18
      
          von iblech
      
    </div>
    
    
  </header>

  <p>Richi gab eine Einführung in die Organisation des Linux-Kernel-Code, mit einem Schwerpunkt auf dem TCP-Stack, also den Dateien unterhalb von <code>net/ipv4/tcp</code>.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/YuV6rxT0mpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</article>
]]></summary>
</entry>
<entry>
    <title>Transfinites Nim und Dagstuhl-Plaudersitzung</title>
    <link href="http://curry-club-augsburg.de/posts/2018-08-08-zweiundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-08-08-zweiundvierzigstes-treffen.html</id>
    <published>2018-08-08T00:00:00Z</published>
    <updated>2018-08-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Transfinites Nim und Dagstuhl-Plaudersitzung</h1>
    <div class="info">
      Gepostet am  8. Aug 18
      
          von MatthiasHu
      
    </div>
    
    
  </header>

  <p>Ingo bietet Spiel und Spaß mit transfinitem Nim:</p>
<p>Nim ist ein mathematisches Strategiespiel. Für Unerfahrene ist es nicht ganz unknifflig, für Eingeweihte völlig trivial. Es nimmt eine zentrale Rolle in der Theorie der sog. neutralen kombinatorischen Spiele ein, weil jede Position in einem solchen Spiel äquivalent zu einer Position in Nim ist.</p>
<p>Jedenfalls wird klassisches Nim mit Haufen von Münzen gespielt. Joel David Hamkins, berühmter Mengentheoretiker und Person mit dem meisten Karma auf MathOverflow, dachte sich: Mit gewöhnlichen Haufen von Münzen kann man heutzutage niemanden mehr locken. Lass das Spiel auf unendlich viele Münzen ausweiten.</p>
<p>Es macht Spaß, diese transfinite Variante von Nim zu spielen und zu erkunden, wie man optimal spielt. Dazu darf man keine Furcht haben, über unendlich hinaus zu zählen.</p>
<p>Optionales Bonuskapitel: Die Geschichte der epischen Schlacht zwischen Herkula und Hydra. Erzählt in vier Akten. Der letzte wird dich umhauen. (Da er eine kleine aber feine metamathematische Weisheit über die Grenzen des logischen Schließens enthält.)</p>
<p>Makarius leitet eine Plaudersitzung dazu an, was in Dagstuhl bei der Veranstaltung <a href="https://www.dagstuhl.de/en/program/calendar/semhp/?semnr=18341">Formalization of Mathematics in Type Theory</a> so los war.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das vierzigste Treffen am 12.7.2018</title>
    <link href="http://curry-club-augsburg.de/posts/2018-07-10-vierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-07-10-vierzigstes-treffen.html</id>
    <published>2018-07-10T00:00:00Z</published>
    <updated>2018-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das vierzigste Treffen am 12.7.2018</h1>
    <div class="info">
      Gepostet am 10. Jul 18
      
          von Profpatsch
      
    </div>
    
    
  </header>

  <p>Profpatsch gibt eine Einführung über Purescript, eine Haskell-artige Sprache mit strikter Semantik, die direkt zu Javascript kompiliert.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Isabelle/VSCode, Language Server Protocol und TypeScript</title>
    <link href="http://curry-club-augsburg.de/posts/2018-07-10-einundvierzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-07-10-einundvierzigstes-treffen.html</id>
    <published>2018-07-10T00:00:00Z</published>
    <updated>2018-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Isabelle/VSCode, Language Server Protocol und TypeScript</h1>
    <div class="info">
      Gepostet am 10. Jul 18
      
          von Makarius
      
    </div>
    
    
  </header>

  <p>Makarius hält einen Vortrag über Isabelle/VSCode, Language Server Protocol und TypeScript:</p>
<p>Als Fortsetzung der Betrachtungen zur Isabelle Prover IDE geht es diesmal um VSCode und das Language Server Protocol für generische IDEs von MicroSoft. Dies ist eine Selbst-Anwendung von VSCode als Entwicklungsplattform für TypeScript — einer relativ neuen typisierten Erweiterung von JavaScript. VSCode ist letztlich eine IDE zur Entwicklung von VSCode in TypeScript, so ähnlich wie Isabelle eine IDE zur Entwicklung von Isabelle in ML (oder anderen domain-specific formal languages) ist.</p>
<p>https://sketis.net/wp-content/uploads/2018/08/Curry-Club_Aug-2018.pdf</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das neununddreissigste Treffen am 14. Juni 2018</title>
    <link href="http://curry-club-augsburg.de/posts/2018-05-28-neununddreissigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2018-05-28-neununddreissigstes-treffen.html</id>
    <published>2018-05-28T00:00:00Z</published>
    <updated>2018-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das neununddreissigste Treffen am 14. Juni 2018</h1>
    <div class="info">
      Gepostet am 28. Mai 18
      
          von Profpatsch
      
    </div>
    
    
  </header>

  <p>Basierend auf <a href="https://sketis.net/wp-content/uploads/2018/05/isabelle-jedit-fide2018.pdf">seinem letzten Bericht</a> wird Makarius uns die Implementierung der aktuellen IDE (basierend auf Scala/jEdit) und die Zukunft der UI (Typescript/VSCode) vorstellen.</p>
</article>
]]></summary>
</entry>

</feed>
